# 	微信小程序

[toc]

## 微信小程序的介绍

### 一.和普通网页的区别：

1.运行环境不同
2.API不同
3.开发模式不同

### 二.小程序的项目组成结构：

pages：用来存放小程序的所有页面
utils；用来存放工具性质的模块
app.js：小程序项目的入口文件
app.json:微信小程序的全局配置文件
app.wxss；小程序项目的全局样式文件
project.config.json:项目的配置文件
sitemap.json用来配置小程序是否允许被其他微信搜索

### 小程序页面的组成部分

小程序官方建议吧所有小程序的页面，都存放在pages文件目录里，以单独的文件夹存在
每个页面文件夹里有四个文件
.js文件（页面的脚本文件，存放页面的数据，事件处理函数）
.json文件（当前页面的配置文件。配置窗口的外观，表现）
.wxml(页面的模板结构文件)
.wxss文件（当前页面的样式文件）

### 小程序代码的构成

#### JSON文件

是一种数据格式，json总是以配置文件的形式存在，通过不同级别的,json配置文件可以对小程序进行不同级别的配置。

##### app.json:微信小程序的全局配置文件

包括小程序的所有页面路径。窗口外观，界面表现，底部tab
demo里的配置文件如下：

``` json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
//  pages： 这是用来记录小程序所有页面的路径
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
//  window 全局定义小程序的所所有页面的背景色，文字颜色等
  "style": "v2",
// style  全局定义小程序组件组件所使用的样式板式
  "sitemapLocation": "sitemap.json"
//sitemapLocation  用来指明sitemap.json的位置

}
```

##### project.config.json:项目的配置文件

记录对小程序的个性化配置

```  json
{
  "description": "项目配置文件",
  "packOptions": {
    "ignore": [
      {
        "type": "file",
        "value": ".eslintrc.js"
      }
    ]
  },
  "setting": {
    "bundle": false,
    "userConfirmedBundleSwitch": false,
    "urlCheck": true,
    "scopeDataCheck": false,
    "coverView": true,
    "es6": true,
    "postcss": true,
    "compileHotReLoad": false,
    "lazyloadPlaceholderEnable": false,
    "preloadBackgroundData": false,
    "minified": true,
    "autoAudits": false,
    "newFeature": false,
    "uglifyFileName": false,
    "uploadWithSourceMap": true,
    "useIsolateContext": true,
    "nodeModules": false,
    "enhance": true,
    "useMultiFrameRuntime": true,
    "useApiHook": true,
    "useApiHostProcess": true,
    "showShadowRootInWxmlPanel": true,
    "packNpmManually": false,
    "enableEngineNative": false,
    "packNpmRelationList": [],
    "minifyWXSS": true,
    "showES6CompileOption": false,
    "minifyWXML": true
  },
  "compileType": "miniprogram",
  "libVersion": "2.19.4",
  "appid": "wxc12928e3b8e14d5e",
  "projectname": "%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%A8%8B%E5%BA%8F",
  "debugOptions": {
    "hidedInDevtools": []
  },
  "scripts": {},
  "staticServerOptions": {
    "baseURL": "",
    "servePath": ""
  },
  "isGameTourist": false,
  "condition": {
    "search": {
      "list": []
    },
    "conversation": {
      "list": []
    },
    "game": {
      "list": []
    },
    "plugin": {
      "list": []
    },
    "gamePlugin": {
      "list": []
    },
    "miniprogram": {
      "list": []
    }
  }
}
```

setting保存编译相关配置
projectname保存项目名称
appid保存小程序账号id（**拿别人的代码记得改这个id**）

##### sitemap.json文件

用来配置小程序是否允许被其他微信搜索
微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO。sitemap.json 文件用来配置小程序页面是否允许
微信索引。
当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页
面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。
注意：sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件
project.config.json 的 setting 中配置字段 checkSiteMap 为 false

##### 页面的 .json 配置文件

小程序中的每一个页面，可以使用 .json 文件来对本页面的窗口外观进行配置，页面中的配置项会覆盖
app.json 的 window 中相同的配置项。（优先级更大）

#### 新建小程序页面

在 app.json -> pages 中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的页面文件，如图所示：（这里添加一个页面a）

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650266655180.png" style="zoom:67%;" />

#### 修改项目首页

只需要调整 app.json -> pages 数组中页面路径的前后顺序，即可修改项目的首页。小程序会把排在第一位的页
面，当作项目首页进行渲染。

#### WXML模板

WXML（WeiXin Markup Language）是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作
用类似于网页开发中的 HTML。

2. WXML 和 HTML 的区别
   ① 标签名称不同
    HTML （div, span, img, a）
    WXML（view, text, image, navigator）
   ② 属性节点不同

``` html
 <a href="#">超链接</a>
 <navigator url="/pages/home/home"></navigator>
```

③ 提供了类似于 Vue 中的模板语法
 数据绑定
 列表渲染
 条件渲染

 #### wxss模板

 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，类似于网页开发中的 CSS。

WXSS 和 CSS 的区别
① 新增了 rpx 尺寸单位
 CSS 中需要手动进行像素单位换算，例如 rem
 WXSS 在底层支持新的尺寸单位 rpx，在不同大小的屏幕上小程序会自动进行换算

② 提供了全局的样式和局部样式
 项目根目录中的 app.wxss 会作用于所有小程序页面
 局部页面的 .wxss 样式仅对当前页面生效

③ WXSS 仅支持部分 CSS 选择器
 .class 和 #id
 element
 并集选择器、后代选择器
 ::after 和 ::before 等伪类选择器

#### JS逻辑交互

 1. 小程序中的 .js 文件
    一个项目仅仅提供界面展示是不够的，在小程序中，我们通过 .js 文件来处理用户的操作。例如：响应用户的
    点击、获取用户的位置等等。
1. 小程序中 .js 文件的分类
   小程序中的 JS 文件分为三大类，分别是：
   ① app.js
    是整个小程序项目的入口文件，通过调用 App() 函数来启动整个小程序
   ② 页面的 .js 文件
    是页面的入口文件，通过调用 Page() 函数来创建并运行页面
   ③ 普通的 .js 文件
    是普通的功能模块文件，用来封装公共的函数或属性供页面使用

## 小程序的宿主环境

### 宿主环境（host environment）

指的是程序运行所必须的依赖环境。例如：
Android 系统和 iOS 系统是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行的，所以Android 是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的！

### 手机微信是小程序的宿主环境

小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能，例如：微信扫码、微信支付、微信登录、地理定位、etc

### 小程序宿主环境包含的内容

#### 通信模型

##### 1.通信的主体

小程序中通信的主体是渲染层和逻辑层，其中：
① WXML 模板和 WXSS 样式工作在渲染层
② JS 脚本工作在逻辑层

##### 2.小程序的通信模型

小程序中的通信模型分为两部分：
① 渲染层和逻辑层之间的通信
 由微信客户端进行转发
② 逻辑层和第三方服务器之间的通信
 由微信客户端进行转发

#### 运行机制

##### 小程序启动的过程

① 把小程序的代码包下载到本地
② 解析 app.json 全局配置文件
③ 执行 app.js 小程序入口文件，调用 App() 创建小程序实例
④ 渲染小程序首页
⑤ 小程序启动完成

##### 页面渲染的过程

① 加载解析页面的 .json 配置文件
② 加载页面的 .wxml 模板和 .wxss 样式
③ 执行页面的 .js 文件，调用 Page() 创建页面实例
④ 页面渲染完成

## 组件

#### 1. 小程序中组件的分类

小程序中的组件也是由宿主环境提供的，开发者可以基于组件快速搭建出漂亮的页面结构。官方把小程序的组
件分为了 9 大类，分别是：
① 视图容器（常用）
② 基础内容（常用）
③ 表单组件（常用）
④ 导航组件（常用）
⑤ 媒体组件
⑥ map 地图组件
⑦ canvas 画布组件
⑧ 开放能力
⑨ 无障碍访问

#### 常用的视图容器类组件

① view
 普通视图区域
 类似于 HTML 中的 div，是一个块级元素
 常用来实现页面的布局效果
② scroll-view
 可滚动的视图区域
 常用来实现滚动列表效果
③ swiper 和 swiper-item
 轮播图容器组件 和 轮播图 item 组件

##### view 组件的基本使用

和html的div没啥区别
实现 flex 横向布局效果：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650267283867.png" style="zoom:67%;" />

结构

``` html
<!--pages/a/a.wxml-->
<view class="container1"> 
<view>A</view>
<view>B</view>
<view>C</view>
</view>
```

样式

``` css
/* pages/a/a.wxss */
.container1{
  display: flex;         /* display:flex(弹性盒子布局) */
  justify-content: space-around;/* 均匀排列每个元素，每个元素周围分配相同的空间 */
}
/*这里是类选择器和后代选择器 */
.container1 view{    
  width: 100px;    
  height: 100px;
  text-align: center;
/*text-align属性规定元素中的文本的水平对齐方式：center水平居中*/
  line-height: 100px;
/*行高，达到纵向居中*/
}
/*伪类选择器，第n个子元素:nth-child(n) */
.container1 view:nth-child(1) {
  background-color: aqua;  /*背景色*/
}
.container1 view:nth-child(2) {
  background-color: burlywood;
}
.container1 view:nth-child(3) {
  background-color: chocolate;
}
```

##### view 组件的基本使用

 scroll-view 组件的基本使用
纵向滚动效果：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650268551841.png" style="zoom:67%;" />

结构：

``` html
<!--pages/a/a.wxml-->
<scroll-view class="container1" scroll-y="1"> 
<view>A</view>
<view>B</view>
<view>C</view>
</scroll-view>
```

样式

``` css
/* pages/a/a.wxss */
.container1{
  border: crimson 1px solid;
  height: 120px;/*给scroll-view固定高度，要实现滚动效果，必须设置高度*/
  width: 100px;
  display: flex;
  justify-content: space-around;
}
.container1 view{
  width: 100px;
  height: 100px;
  text-align: center;
  line-height: 100px;
}
.container1 view:nth-child(1) {
  background-color: aqua;
}
.container1 view:nth-child(2) {
  background-color: burlywood;
}
.container1 view:nth-child(3) {
  background-color: chocolate;
}
```

##### swiper 和 swiper-item 组件的基本使用

实现轮播图效果：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650268877314.png" style="zoom: 67%;" />

结构

``` html
<!--pages/a/a.wxml-->
<!-- 轮播图结构 -->
<swiper class="swioer-container" indicator-dots="true">	<!-- 是否显示面板指示点 -->
<!-- 第一个轮播图 -->
<swiper-item>
  <view class="item">A</view>
</swiper-item>
<!-- 第二个轮播图 -->
<swiper-item>
  <view class="item">B</view>
</swiper-item>
<!-- 第三个轮播图 -->
<swiper-item>
  <view class="item">C</view>
</swiper-item>
</swiper>
```

样式

``` css
/* pages/a/a.wxss */
.swioer-container{
  height: 150px;
}
.item{
  height: 100%;
  line-height: 150px;
  text-align: center;
}
swiper-item:nth-child(1) .item{
  background-color: aqua;
}
swiper-item:nth-child(2) .item{
  background-color: rgb(101, 211, 116);
}
swiper-item:nth-child(3) .item{
  background-color: rgb(231, 102, 113);
}
```

swiper组件的常用属性：

![image-20220418162251719](C:\Users\xin\AppData\Roaming\Typora\typora-user-images\image-20220418162251719.png)

#### 常用的基础内容组件

##### text文本组件

 类似于 HTML 中的 span 标签，是一个行内元素

#####  rich-text富文本组件

 支持把 HTML 字符串渲染为 WXML 结构  

##### text 组件的基本使用

通过 text 组件的 selectable 属性，实现长按选中文本内容的效果：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650271035868.png" style="zoom: 80%;" />

结构：

```html
<!-- pages/a/a.wxml -->
<!-- 常用的基础内容组件txet和rich-text的用法 -->
<view>
手机号支持长按选中效果
<text user-select>1324534623</text>
</view>
```

##### rich-text 组件的基本使用

通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构：  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650271343905.png)

结构：

```html
<rich-text nodes="<h1 style='color: red;'>标题</h1>"></rich-text>
```



#### 其他常用组件

##### button 按钮组件

功能比 HTML 中的 button 按钮丰富
 通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）

##### button 按钮的基本使用

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650272488115.png" style="zoom:67%;" />

代码：

```html
<!-- pages/a/a.wxml -->
<!-- 按钮组件的基本使用 -->
<view>-----通过type属性指定按钮颜色类型------- </view>
<button>普通按钮</button>
<button type="primary">主色调按钮</button>
<button type="warn">警告按钮</button>
<view>-----通过size属性指定按钮大小类型------- </view>
<button size="mini">普通按钮</button>
<button type="primary" size="mini">主色调按钮</button>
<button type="warn" size="mini">警告按钮</button>
<view>-----通过plain属性设置镂空按钮------- </view>
<button size="mini" plain="true">普通按钮</button>
<button type="primary" size="mini" plain="true">主色调按钮</button>
<button type="warn" size="mini" plain="true">警告按钮</button>
```

##### image图片组件

 image 组件默认宽度约 300px、高度约 240px

##### image 组件的基本使用

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650273012785.png" style="zoom:67%;" />

代码：

```html
<!-- pages/a/a.wxml -->
<!--  image 组件的基本使用-->
<image></image>
<image src="/images/1.png" mode="aspectFit"></image>
```



###### image 组件的 mode 属性

image 组件的 mode 属性用来指定图片的裁剪和缩放模式，常用的 mode 属性值如下：  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650272903084.png)

#####  navigator（后面课程会专门讲解）页面导航组件

 类似于 HTML 中的 a 链接  

## API

### 小程序 API 概述

小程序中的 API 是由宿主环境提供的，通过这些丰富的小程序 API，开发者可以方便的调用微信提供的能力，
例如：获取用户信息、本地存储、支付功能等。  

### 小程序 API 的 3 大分类

小程序官方把 API 分为了如下 3 大类：

#### 事件监听 API

 特点：以 **on** 开头，用来监听某些事件的触发
 举例：wx.onWindowResize(function callback) 监听窗口尺寸变化的事件

####  同步 API

 特点1：以 **Sync** 结尾的 API 都是同步 API
 特点2：同步 API 的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常
 举例：wx.setStorageSync('key', 'value') 向本地存储中写入内容

#### 异步 API

 特点：类似于 jQuery 中的 $.ajax(options) 函数，需要通过 success、fail、complete 接收调用的结果
 举例：wx.request() 发起网络数据请求，通过 success 回调函数接收数据  

## 小程序模板与配置

### WXML 模板语法

#### WXML 模板语法 - 数据绑定

##### 1.数据绑定的基本原则

① 在 data 中定义数据

② 在 WXML 中使用数据  

##### 2.在 data 中定义页面的数据

在页面对应的 .js 文件中，把数据定义到 data 对象中即可： 

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650275692933.png" style="zoom: 80%;" />

 

##### 3.Mustache 语法的格式

把data中的数据绑定到页面中渲染，使用 Mustache 语法（双大括号）将变量包起来即可。语法格式为：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650275739400.png" style="zoom: 80%;" />

##### 4.Mustache 语法的应用场景

Mustache 语法的主要应用场景如下：
 绑定内容
 绑定属性
 运算（三元运算、算术运算等）  

##### 5.动态绑定内容

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650275930225.png" style="zoom: 67%;" />

##### 6. 动态绑定属性

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650275985108.png" style="zoom:67%;" />

示例：

绑定：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650276358968.png" style="zoom:67%;" />

调用;

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650276529355.png" style="zoom:67%;" />

##### 7.三元运算

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650276618862.png" style="zoom:67%;" />

示例：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650294533791.png" style="zoom:67%;" />

效果：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650294574834.png" style="zoom:67%;" />

##### 8.算数运算

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650294848500.png" style="zoom:67%;" />

#### WXML 模板语法 - 事件绑定

##### 1.什么是事件

事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务的处理。  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650294987804.png" style="zoom:67%;" />

##### 2. 小程序中常用的事件

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650295562887.png)

##### 3.事件对象的属性列表

当事件回调触发的时候，会收到一个事件对象 event，它的详细属性如下表所示  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650295525316.png)

##### 4. target 和 currentTarget 的区别

target 是触发该事件的源头组件，而 currentTarget 则是当前事件所绑定的组件。

 currentTarget 是绑定的那个，target 是实际被点击的那个。

举例如下：  

![image-20220418232647920](C:\Users\xin\AppData\Roaming\Typora\typora-user-images\image-20220418232647920.png)

点击内部的按钮时，点击事件以冒泡的方式向外扩散，也会触发外层 view 的 tap 事件处理函数。
此时，对于外层的 view 来说：
 e.target 指向的是触发事件的源头组件，因此，e.target 是内部的按钮组件
 e.currentTarget 指向的是当前正在触发事件的那个组件，因此，e.currentTarget 是当前的 view 组件  

##### 5. bindtap 的语法格式

在小程序中，不存在 HTML 中的 onclick 鼠标点击事件，而是通过 tap 事件来响应用户的触摸行为。
① 通过 bindtap，可以为组件绑定 tap 触摸事件，语法如下：  

```html
<!-- 绑定事件 -->
<button type="primary" bindtap="bthTapHandler">按钮</button>
```

② 在页面的 .js 文件中定义对应的事件处理函数，事件参数通过形参 event（一般简写成 e） 来接收：  

```js
page({
    //定义事件函数
    bthTapHandler(e){ //按钮的 tap 事件处理函数
        console.log(e)//事件参数对象 e
    }
})
```

##### 6. 在事件处理函数中为 data 中的数据赋值

通过调用 this.setData(dataObject) 方法，可以给页面 data 中的数据重新赋值，示例如下：  

js文件

```js
page({
  data: {
    count: 0
  },
  //修改 count 的值 (加一按钮)
  changCount(){
    this.setData({
      count:this.data.count + 1
    })
  }
})
```

wxhl文件

```html
<button type="primary" bindtap="changCount"> +1 </button>
```

效果：点击+1     count:的值加一

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650299352548.png)

##### 7. 事件传参

小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。例如，下面的代码将不能正常工作：  

```html
<button type="primary" bindtap='btnHandler(123)'>事件传参</button>
```

因为小程序会把 bindtap 的属性值，统一当作事件名称来处理，相当于要调用一个名称为 btnHandler(123)的事件处理函数。  

可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字，示例代码如下：  

```html
<button bindtap:="btnHandler" data-info="{{2}}">事件传参</button>
```

最终：
		 info 会被解析为参数的名字
		 数值 2 会被解析为参数的值  

在事件处理函数中，通过 event.target.dataset.参数名 即可获取到具体参数的值，示例代码如下：  

```js
btnHandler(event){
//dataset是一个对象，包含了所有通过data-*传递过来的参数项
console.log(event.target.dataset)
//通过dataset可以访问到具体参数的值
console.log(event.target.dataset.info)
}
```

**示例：**利用事件传参实现加二按钮

js文件

```js
page({
  data: {
    count: 0
  },
  //修改 count 的值 (加二按钮)
  btnHandler(event){
    this.setData({
      count: this.data.count + event.target.dataset.info  //重点！
    })
    }
})
```

wxhl文件

```html
<button type="primary" bindtap="btnHandler" data-info="{{2}}"> +2 </button>
```

效果：按下+2，count的值加2

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650299546321.png)



##### 8.bindinput 的语法格式

在小程序中，通过 input 事件来响应文本框的输入事件，语法格式如下：
① 通过 bindinput，可以为文本框绑定输入事件：

```html
<input bindinput="inputHandler" type="text"/>
```

② 在页面的 .js 文件中定义事件处理函数：  

```js
  //输入框事件处理函数
  inputHandler(e){
      //e.detail.value是变化过后，文本框的最新值
    console.log(e.detail.value)
  },
```

##### 9.实现文本框和 data 之间的数据同步

实现步骤：
① 定义数据

```js
page({
	data:{
	msg:'你好，'
	}
})
```

② 渲染结构

```html
<input value="{{msg}}" bindinput="inputHandler"  type="text" />
```

③ 美化样式

```css
input{
border:1px solid #eee;
padding:5px;
margin:5px;
border-radius:3px;
}
```

④ 绑定 input 事件处理函数  

```js
  //文本框内容改变事件
  inputHandler(e){
   this.setData({
    //e.detail.value是变化过后，文本框的最新值
    msg:e.detail.value
      })     
  },
```

#### WXML 模板语法 - 条件渲染

##### 1.wx:if

在小程序中，使用 wx:if="{{condition}}" 来判断是否需要渲染该代码块：

```html
<view wx:if="{{condition}}">True </view>
```

也可以用 wx:elif 和 wx:else 来添加 else 判断：  

```html
<view wx:if="{{type ==1}}">男</view>
<view wx:elif="{{type ==2}}">女</view>
<view wx:else>保密</view>
```

##### 2.结合 block 使用 wx:if

如果要一次性控制多个组件的展示与隐藏，可以使用一个 <block></block>标签将多个组件包装起来，并在
<block> 标签上使用 wx:if 控制属性，示例如下：

```html
<block wx:if="{{true}}">
<view>view1 </view>
<view>view2 </view>
</block>
```

注意： <block> 并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染。  

##### 4. hidden

在小程序中，直接使用 hidden="{{ condition }}" 也能控制元素的显示与隐藏：  

根据condition的值（true/false）来判断：

```html
<view hidden="{{condition}}">条件为true隐藏，条件为false显示</view>
```

##### 4.wx:if 与 hidden 的对比

① 运行方式不同
 wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏
 hidden 以切换样式的方式（display: none/block;），控制元素的显示与隐藏

② 使用建议
 频繁切换时，建议使用 hidden
 控制条件复杂时，建议使用 wx:if 搭配 wx:elif、wx:else 进行展示与隐藏的切换  

#### WXML 模板语法 - 列表渲染

##### 1.wx:for

通过 wx:for 可以根据指定的数组，循环渲染重复的组件结构，语法示例如下：

js:

```js
data: {
    array:['苹果','华为','小米']
},
```

wxml:

```html
<view wx:for="{{array}}">
索引是：{{index}}当前项是：{{item}}
</view>
```

效果：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650331942932.png" style="zoom:67%;" />

默认情况下，当前循环项的索引用 index 表示；当前循环项用 item 表示。  

##### 2.手动指定索引和当前项的变量名

 使用 wx:for-index 可以指定当前循环项的索引的变量名
 使用 wx:for-item 可以指定当前项的变量名
示例代码如下：  

```html
<view wx:for="{{array}}"wx:for-index="idx"wx:for-item="itemName">
索引是：{{idx}}当前项是：{itemName}}
</view>
```

##### 3.wx:key 的使用

类似于 Vue 列表渲染中的 :key，小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的 key 值，
从而提高渲染的效率，示例代码如下： 

```js
//.js  data数据
data:{
    userList:[
      {id:1,name:'小红'},
      {id:2,name:'小黄'},
      {id:3,name:'小白'}
     ]
}
```

wxml代码：

```html
<view wx:for="{{userList}}"wx:key="id">{{item.name}}</view>
```

### WXSS 模板样式

#### 1. 什么是 WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的 CSS。  

#### 2.WXSS 和 CSS 的关系

WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。
与 CSS 相比，WXSS 扩展的特性有：

WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。
与 CSS 相比，WXSS 扩展的特性有：

1. rpx 尺寸单位
2. @import 样式导入 

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650333929028.png" style="zoom:67%;" />



#### WXSS 模板样式- rpx

##### 1.什么是 rpx 尺寸单位
rpx（responsive pixel）是微信小程序独有的，用来解决屏适配的尺寸单位。  

##### 2.rpx 的实现原理
rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕，
在宽度上等分为 750 份（即：当前屏幕的总宽度为 750rpx）。
在较小的设备上，1rpx 所代表的宽度较小
在较大的设备上，1rpx 所代表的宽度较大
小程序在不同设备上运行的时候，会自动把 rpx 的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配。  

##### 3.rpx 与 px 之间的单位换算*
在 iPhone6 上，屏幕宽度为375px，共有 750 个物理像素，等分为 750rpx。则：
750rpx = 375px = 750 物理像素
1rpx = 0.5px = 1物理像素  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650334417413.png" style="zoom:67%;" />

官方建议：开发微信小程序时，设计师可以用 iPhone6 作为视觉稿的标准。
开发举例：在 iPhone6 上如果要绘制宽100px，高20px的盒子，换算成rpx单位，宽高分别为 200rpx 和 40rpx。  

#### WXSS 模板样式 - 样式导入  

##### 1.什么是样式导入
使用 WXSS 提供的 @import 语法，可以导入外联的样式表。  

##### 2.@import 的语法格式

@import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。示例如下：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650334716433.png" style="zoom:67%;" />

#### WXSS 模板样式 - 全局样式和局部样式  

##### 1. 全局样式
定义在 app.wxss 中的样式为全局样式，作用于每一个页面。  

##### 2.局部样式
在页面的 .wxss 文件中定义的样式为局部样式，只作用于当前页面。
注意：
① 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式
② 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式  

### 全局配置

#### 全局配置文件及常用的配置项

小程序根目录下的 app.json 文件是小程序的全局配置文件。常用的配置项如下：
① pages
 记录当前小程序所有页面的存放路径
② window
 全局设置小程序窗口的外观
③ tabBar
 设置小程序底部的 tabBar 效果
④ style
 是否启用新版的组件样式  

#### 全局配置 - window

##### 1.小程序窗口的组成部分

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650335447115.png" style="zoom:67%;" />

##### 2.了解 window 节点常用的配置项

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650335548757.png" style="zoom:67%;" />

##### 3.设置导航栏的标题
设置步骤：app.json -> window -> navigationBarTitleText
需求：把导航栏上的标题，从默认的 “WeChat”修改为“黑马程序员”，效果如图所示：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650335704219.png" style="zoom:67%;" />

##### 4.设置导航栏的背景色

设置步骤：app.json -> window -> navigationBarBackgroundColor
需求：把导航栏标题的背景色，从默认的 #fff 修改为 #2b4b6b ，效果如图所示：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650335768810.png" style="zoom:67%;" />

##### 5. 设置导航栏的标题颜色
设置步骤：app.json -> window -> navigationBarTextStyle
需求：把导航栏上的标题颜色，从默认的 black 修改为 white ，效果如图所示：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650335910069.png" style="zoom:67%;" />

注意： navigationBarTextStyle 的可选值只有 black 和 white  

##### 6. 全局开启下拉刷新功能
概念：下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。
设置步骤：app.json -> window -> 把 enablePullDownRefresh 的值设置为 true

注意：在 app.json 中启用下拉刷新功能，会作用于每个小程序页面！  

##### 7.设置下拉刷新时窗口的背景色

当全局开启下拉刷新功能之后，默认的窗口背景为白色。如果自定义下拉刷新窗口背景色，设置步骤为:
app.json -> window -> 为 backgroundColor 指定16进制的颜色值 #efefef。效果如下：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650336417559.png" style="zoom:67%;" />

##### 8. 设置下拉刷新时 loading 的样式
当全局开启下拉刷新功能之后，默认窗口的 loading 样式为白色，如果要更改 loading 样式的效果，设置步
骤为 app.json -> window -> 为 backgroundTextStyle 指定 dark 值。效果如下：  

<img src="C:\Users\xin\AppData\Roaming\Typora\typora-user-images\image-20220419104857074.png" alt="image-20220419104857074" style="zoom:67%;" />

注意： backgroundTextStyle 的可选值只有 light 和 dark  

##### 9.设置上拉触底的距离
概念：上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。
设置步骤： app.json -> window -> 为 onReachBottomDistance 设置新的数值
注意：默认距离为50px，如果没有特殊需求，建议使用默认值即可。  

#### 全局配置 - tabBar  

##### 1.什么是 tabBar

tabBar 是移动端应用常见的页面效果，用于实现多页面的快速切换。小程序中通常将其分为：
底部 tabBar      顶部 tabBar

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650337142163.png" style="zoom:67%;" />

注意：
 tabBar中只能配置最少 2 个、最多 5 个 tab 页签. 当渲染顶部 tabBar 时，不显示 icon，只显示文本  

##### 2. tabBar 的 6 个组成部分
① backgroundColor：tabBar 的背景色
② selectedIconPath：选中时的图片路径
③ borderStyle：tabBar 上边框的颜色
④ iconPath：未选中时的图片路径
⑤ selectedColor：tab 上的文字选中时的颜色
⑥ color：tab 上文字的默认（未选中）颜 色

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650337250686.png" style="zoom:67%;" />

##### 3. tabBar 节点的配置项

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650337827339.png)

##### 4.每个 tab 项的配置选项  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650337815060.png)

示例：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650338101311.png" style="zoom:67%;" />

##### 全局配置 - 案例：配置 tabBar

###### 1.根据资料中提供的小图标、在小程序中配置如图所示的tabBar 效果  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650338275888.png" style="zoom:67%;" />

###### 2.实现步骤

① 拷贝图标资源
② 新建 3 个对应的 tab 页面
③ 配置 tabBar 选项  

###### 3. 步骤1 - 拷贝图标资源

① 把资料目录中的 images 文件夹，拷贝到小程序项目根目录中
② 将需要用到的小图标分为 3 组，每组两个，其中：
 图片名称中包含 -active 的是选中之后的图标
 图片名称中不包含 -active 的是默认图标
截图如下  ：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650338407777.png" style="zoom:67%;" />

######  步骤2 - 新建 3 个对应的 tab 页面

通过 app.json 文件的 pages 节点，快速新建 3 个对应的 tab 页面，示例代码如下：  

```js
{ 
"pages":[
    "pages/home/home",
    "pages/message/message",
    "pages/contact/contact"
  ],
}
```

其中，home 是首页，message 是消息页面，contact 是联系我们页面。  

###### 步骤3 - 配置 tabBar 选项

① 打开 app.json 配置文件，和 pages、window 平级，新增 tabBar 节点
② tabBar 节点中，新增 list 数组，这个数组中存放的，是每个 tab 项的配置对象
③ 在 list 数组中，新增每一个 tab 项的配置对象。对象中包含的属性如下：
 pagePath 指定当前 tab 对应的页面路径【必填】
 text 指定当前 tab 上按钮的文字【必填】
 iconPath 指定当前 tab 未选中时候的图片路径【可选】
 selectedIconPath 指定当前 tab 被选中后高亮的图片路径【可选】  

代码：

```js
  "tabBar": {
    "list": [{
      "pagePath": "pages/home/home",
      "text": "首页",
      "iconPath": "/images/tabs/home.png",
      "selectedIconPath": "/images/tabs/home-active.png"
    },{
      "pagePath": "pages/message/message",
      "text": "消息",
      "iconPath": "/images/tabs/message.png",
      "selectedIconPath": "/images/tabs/message-active.png"
    },{
      "pagePath": "pages/contact/contact",
      "text": "联系我们",
      "iconPath": "/images/tabs/contact.png",
      "selectedIconPath": "/images/tabs/contact-active.png"
    }]
  },
```

效果：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650339313283.png" style="zoom:67%;" />

### 页面配置

#### 1. 页面配置文件的作用
小程序中，每个页面都有自己的 .json 配置文件，用来对当前页面的窗口外观、页面效果等进行配置。  

#### 2.页面配置和全局配置的关系

小程序中，app.json 中的 window 节点，可以全局配置小程序中每个页面的窗口表现。
如果某些小程序页面想要拥有特殊的窗口表现，此时，“页面级别的 .json 配置文件”就可以实现这种需求。
注意：当页面配置与全局配置冲突时，根据就近原则，最终的效果以页面配置为准。  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650340309160.png)

### 网络数据请求  

#### 1.小程序中网络数据请求的限制

出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下两个限制：
① 只能请求 HTTPS 类型的接口
② 必须将接口的域名添加到信任列表中  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650343146330.png" style="zoom:67%;" />

#### 2.配置 request 合法域名

需求描述：假设在自己的微信小程序中，希望请求 https://www.escook.cn/ 域名下的接口
配置步骤：登录微信小程序管理后台 -> 开发 -> 开发设置 -> 服务器域名 -> 修改 request 合法域名
注意事项：
① 域名只支持 https 协议
② 域名不能使用 IP 地址或 localhost
③ 域名必须经过 ICP 备案
④ 服务器域名一个月内最多可申请 5 次修改  

#### 3. 发起 GET 请求

调用微信小程序提供的 wx.request() 方法，可以发起 GET 数据请求，示例代码如下：  

wxml:

```html
<button bindtap="getinfo">发起get请求</button>
```

js:

```js
  //发起get 数据请求
  getinfo(){
    wx.request({
      url:'https://w.escook.cn/api/get',//请求的接口地址，必须基于https协议
      method:'GET',  //请求的方式
      data:    //发送到服务器的数据
      {
        name:'zs',
        age:22
      },
      success:(res) =>{                    //请求成功之后的回调函数
      console.log(res.data)
      }
      })
  },
```

#### 4.发起 POST 请求

调用微信小程序提供的 wx.request() 方法，可以发起 POST 数据请求，示例代码如下：  

```js
  postInfo(){
    wx.request({
      url:'https://www.escook.cn/api/post',//请求的接口地址，必须基于https协议
      method:'POST',  //请求的方式
      data:    //发送到服务器的数据
      {
        name:'Ls',
        age:22
      },
      success:(res) =>{                    //请求成功之后的回调函数
      console.log(res.data)
      }
      })
  },
```

#### 5.在页面刚加载时请求数据

在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的 onLoad 事件
中调用获取数据的函数，示例代码如下：  

```js
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {//页面加载就会调用这两个方法
    this.getinfo
    this.postInfo
  },

```

#### 6.跳过 request 合法域名校验

如果后端程序员仅仅提供了 http 协议的接口、暂时没有提供 https协议的接口。
此时为了不耽误开发的进度，我们可以在微信开发者工具中，临时开启「开发环境不校验请求域名、TLS 版本及 HTTPS 证书」选项，
跳过 request 合法域名的校验。
注意：跳过 request 合法域名校验的选项，仅限在开发与调试阶段使用！  

#### 6.关于跨域和 Ajax 的说明

跨域问题只存在于基于浏览器的 Web 开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，所以小
程序中不存在跨域的问题。
Ajax 技术的核心是依赖于浏览器中的 XMLHttpRequest 这个对象，由于小程序的宿主环境是微信客户端，所
以小程序中不能叫做“发起 Ajax 请求”，而是叫做“发起网络数据请求”。  

### 案例：本地生活首页：

##### 1.首页效果以及实现步骤

① 新建项目并梳理项目结构
② 配置导航栏效果
③ 配置 tabBar 效果
④ 实现轮播图效果
⑤ 实现九宫格效果
⑥ 实现图片布局  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650362353675.png" style="zoom:67%;" />

#####  接口地址
① 获取轮播图数据列表的接口
 【GET】https://www.escook.cn/slides
② 获取九宫格数据列表的接口
 【GET】https://www.escook.cn/categories  

## 小程序 - 视图与逻辑

### 页面导航

#### 1.什么是页面导航

页面导航指的是页面之间的相互跳转。例如，浏览器中实现页面导航的方式有如下两种：
① <a> 链接
② location.href  

#### 2. 小程序中实现页面导航的两种方式

① 声明式导航
 在页面上声明一个 <navigator> 导航组件
 通过点击 <navigator> 组件实现页面跳转
② 编程式导航
 调用小程序的导航 API，实现页面的跳转  

#### 页面导航 - 声明式导航

##### 1.导航到 tabBar 页面

tabBar 页面指的是被配置为 tabBar 的页面。
在使用 <navigator> 组件跳转到指定的 tabBar 页面时，需要指定 url 属性和 open-type 属性，其中：
 url 表示要跳转的页面的地址，必须以 / 开头
 open-type 表示跳转的方式，必须为 switchTab
示例代码如下：  

```html
<navigator url="/pages/message/message"open-type="switchTab">导航到消息页面</navigator>
```

##### 2.导航到非 tabBar 页面

非 tabBar 页面指的是没有被配置为 tabBar 的页面。
在使用 <navigator> 组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 open-type 属性，其中：
 url 表示要跳转的页面的地址，必须以 / 开头
 open-type 表示跳转的方式，必须为 navigate
示例代码如下：  

```html
<navigator url="/pages/info/info"open-type="navigate">导航到info页面</navigator>
```

注意：为了简便，在导航到非 tabBar 页面时，open-type="navigate" 属性可以省略。  

##### 3.后退导航
如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中：
 open-type 的值必须是 navigateBack，表示要进行后退导航
 delta 的值必须是数字，表示要后退的层级
示例代码如下：

```html
<navigator open-type='navigateBack'delta-'1'>返▣上一页</navigator>
```

注意：为了简便，如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是 1。  

#### 页面导航 - 编程式导航  

##### 导航到 tabBar 页面

调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。其中 Object 参数对象的属性列表如下：  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650428622847.png)

示例代码：

```html
//页面结构
<button bindtap="gotoMessage">跳转到消息页面<button>
```

```js
 //通过编程式导航，跳转到message页面
  gotoMessage() {
    wx.switchTab({
       url:'/pages/message/message'
  })
  },
```

#####  导航到非 tabBar 页面

调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。其中 Object 参数对象的属性列表如下：  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650429017745.png)

示例代码：

```html
//页面结构
<button bindtap="gotoInfo">跳转到info页面</button>
```

```js
  //通过编程式导航，跳转到info页面
  gotoInfo(){
    wx.navigateTo({
      url: '/pages/info/info',
    })
  },
```

##### 后退导航

调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。其中 Object 参数对象可选的
属性列表如下：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650429378222.png" style="zoom:67%;" />

示例代码：

```html
<button bindtap="goBack">后退</button>
```

```js
  //通过编程式导航，进行后退
  goBack(){
    wx.navigateBack({
      delta: 1,
    })
  },
```

#### 页面导航 - 导航传参  

#####  1.声明式导航传参

navigator 组件的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数：
 参数与路径之间使用 ? 分隔
 参数键与参数值用 = 相连
 不同参数用 & 分隔
代码示例如下：  

```html
x 1<navigator url="/pages/info/info?name=zs&age=20">跳转到info页面</navigator>
```



#####  2.编程式导航传参

调用 wx.navigateTo(Object object) 方法跳转页面时，也可以携带参数，代码示例如下：  

```html
//页面结构
<button bindtap="gotoInfo.2">跳转到info页面</button>
```

```js
//通过编程式导航，跳转到info页面，并携带参数
gotoInfo2(){
    wx.navigateTo({
        url: '/pages/info/info?name=zs&age=20',
    })
},
```



##### 3/在 onLoad 中接收导航参数

通过声明式导航传参或编程式导航传参所携带的参数，可以直接在 onLoad 事件中直接获取到，示例代码如下：  

```js
 /**
   * 页面的初始数据
   */
  data: {
    query:{}//定义一个用来保存传参的变量
  },
/**
* 生命周期函数--监听页面加载
*/
onLoad: function (options) {
    //options就是导航传递过来的参数对象
    console.log(options)
    this.setData({
        query:options//将得到的值赋值给变量query
    })
},
```

### 页面事件

#### 下拉刷新

#####  1.什么是下拉刷新

下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。  

##### 2. 启用下拉刷新

启用下拉刷新有两种方式：
① 全局开启下拉刷新
 在 app.json 的 window 节点中，将 enablePullDownRefresh 设置为 true
② 局部开启下拉刷新
 在页面的 .json 配置文件中，将 enablePullDownRefresh 设置为 true
在实际开发中，推荐使用第 2 种方式，为需要的页面单独开启下拉刷新的效果。  

##### 3.配置下拉刷新窗口的样式

在全局或页面的 .json 配置文件中，通过 backgroundColor 和 backgroundTextStyle 来配置下拉刷新窗口
的样式，其中：
 backgroundColor 用来配置下拉刷新窗口的背景颜色，仅支持16 进制的颜色值
 backgroundTextStyle 用来配置下拉刷新 loading 的样式，仅支持 dark 和 light  

##### 4.监听页面的下拉刷新事件

在页面的 .js 文件中，通过 onPullDownRefresh() 函数即可监听当前页面的下拉刷新事件。
例如，在页面的 wxml 中有如下的 UI 结构，点击按钮可以让 count 值自增 +1：  

```html
<!--pages/message/message.wxml-->
<view>count值为：{{count}}</view>
<button bindtap="countAdd">+1</button>
```

```js
// pages/message/message.js
//+1按钮的点击事件处理函数,count要在data里先定义
countAdd(){
    this.setData({
    count:this.data.count 1
    })
}
```

在触发页面的下拉刷新事件的时候，如果要把 count 的值重置为 0，示例代码如下：  

```js
// pages/message/message.js
/**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    //触发消息页面的下拉刷新
    this.setData({
      count:0
    })
  },
```

##### 5. 停止下拉刷新的效果

当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失，所以需要手动隐藏下拉刷新的
loading 效果。此时，调用 wx.stopPullDownRefresh() 可以停止当前页面的下拉刷新。示例代码如下：  

```js
// pages/message/message.js
/**
* 页面相关事件处理函数--监听用户下拉动作
*/
onPullDownRefresh: function () {
    //触发消息页面的下拉刷新
    this.setData({
        count:0
    })
    wx.stopPullDownRefresh()
},
```

#### 上拉触底

##### 1.什么是上拉触底
上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。

##### 2. 监听页面的上拉触底事件
在页面的 .js 文件中，通过 onReachBottom() 函数即可监听当前页面的上拉触底事件。示例代码如下：   

```js
  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    console.log("触发了上拉触底的事件")
  },
```

##### 3.配置上拉触底距离

上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离。
可以在全局或页面的 .json 配置文件中，通过 onReachBottomDistance 属性来配置上拉触底的距离。
小程序默认的触底距离是 50px，在实际开发中，可以根据自己的需求修改这个默认值。  

##### 4.上拉触底案例

###### 1、示例效果：

  <img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650535113574.png" style="zoom:67%;" />

###### 2.案例的实现步骤
① 定义获取随机颜色的方法
② 在页面加载时获取初始数据
③ 渲染 UI 结构并美化页面效果
④ 在上拉触底时调用获取随机颜色的方法
⑤ 添加 loading 提示效果
⑥ 对上拉触底进行节流处理  

###### 3. 步骤1 - 定义获取随机颜色的方法

```js
  data: {
    colorlsit:[]//随机颜色列表
  },
  getClors(){	//获取颜色的方法
    wx.request({//发起请求
      url: 'https://www.escook.cn/api/color',
      method:"GET",
      success:({data:res})=>{
        console.log(res)
        this.setData({
          colorlsit:[...this.data.colorlsit,...res.data]//将获取到的新数组和原数组通过展开运算符进行拼接
        })
      },
    })
  },
```

###### 3. 步骤2 - 在页面加载时获取初始数据

```js
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    this.getClors()
  },

```

###### 3. 步骤3 - 渲染 UI 结构并美化页面效果

```html
<!--pages/contact/contact.wxml-->
<view wx:for="{{colorlsit}}" wx:key="index" class="num-iten" style="background-color: rgba({{item}});">{{item}}</view>
```

```css
/* pages/contact/contact.wxss */
.num-iten{
  border: 1rpx solid #efefef;
  border-radius: 8rpx;
  line-height: 200rpx;
  margin: 15rpx;
  text-align: center;
  text-shadow: 0rpx  0rpx  5rpx #fff;
  box-shadow:1rpx  1rpx  6rpx #aaa ;
}
```

###### 3. 步骤4 - 上拉触底时获取随机颜色

```js
  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    //调用获取随机颜色的方法
    this.getClors()
  },
```

###### 3. 步骤5 - 添加 loading 提示效果

```js
  getClors(){
    //展示loading效果
    wx.showLoading({
      title: '数据加载中...',
    })
    wx.request({
      url: 'https://www.escook.cn/api/color',
      method:"GET",
      success:({data:res})=>{
        console.log(res)
        this.setData({
          colorlsit:[...this.data.colorlsit,...res.data]
        })
      },
      complete:()=>{
        wx.hideLoading()//关闭loading效果
      }
    })
  },
```

###### 3. 步骤6 - 对上拉触底进行节流处理

① 在 data 中定义 isloading 节流阀
 false 表示当前没有进行任何数据请求
 true 表示当前正在进行数据请求

```js
  data: {
    colorlsit:[],
    isloding:false//节流阀
  },
```

② 在 getColors() 方法中修改 isloading 节流阀的值
 在刚调用 getColors 时将节流阀设置 true
 在网络请求的 complete 回调函数中，将节流阀重置为 false

```js
getClors(){
    this.setData({//节流阀
      isloding:true
    }),
    //需要展示loading效果
    wx.showLoading({
      title: '数据加载中...',
    })
    wx.request({
      url: 'https://www.escook.cn/api/color',
      method:"GET",
      success:({data:res})=>{
        console.log(res)
        this.setData({
          colorlsit:[...this.data.colorlsit,...res.data]
        })
      },
      complete:()=>{
        wx.hideLoading(),
        this.setData({
          isloding:false//节流阀
        })
      }
    })
  },
```

③ 在 onReachBottom 中判断节流阀的值，从而对数据请求进行节流控制
 如果节流阀的值为 true，则阻止当前请求
 如果节流阀的值为 false，则发起数据请求  

```js
 /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    //调用获取随机颜色的方法
    if(this.data.isloding)return//判断节流阀
    this.getClors()
  },
```

### 生命周期

#### 1.什么是生命周期

生命周期（Life Cycle）是指一个对象从创建 -> 运行 -> 销毁的整个阶段，强调的是一个时间段。例如：
 张三出生，表示这个人生命周期的开始
 张三离世，表示这个人生命周期的结束
 中间张三的一生，就是张三的生命周期
我们可以把每个小程序运行的过程，也概括为生命周期：
 小程序的启动，表示生命周期的开始
 小程序的关闭，表示生命周期的结束
 中间小程序运行的过程，就是小程序的生命周期  

#### 2.生命周期的分类

在小程序中，生命周期分为两类，分别是：
① 应用生命周期
 特指小程序从启动 -> 运行 -> 销毁的过程
② 页面生命周期
 特指小程序中，每个页面的加载 -> 渲染 -> 销毁的过程
其中，页面的生命周期范围较小，应用程序的生命周期范围较大，如图所示：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650543517547.png" style="zoom:67%;" />

#### 3.什么是生命周期函数

生命周期函数：是由小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行。
生命周期函数的作用：允许程序员在特定的时间点，执行某些特定的操作。例如，页面刚加载的时候，可以在
onLoad 生命周期函数中初始化页面的数据。
注意：生命周期强调的是时间段，生命周期函数强调的是时间点。  

#### 4.. 生命周期函数的分类
小程序中的生命周期函数分为两类，分别是：
① 应用的生命周期函数
 特指小程序从启动 -> 运行 -> 销毁期间依次调用的那些函数
② 页面的生命周期函数
 特指小程序中，每个页面从加载 -> 渲染 -> 销毁期间依次调用的那些函数  

#### 5.应用的生命周期函数
小程序的应用生命周期函数需要在 app.js 中进行声明，示例代码如下：  

```JS
//app.js文件
App({
ithe
//小程序初始化完成时，执行此函数，全局只触发一次。可以做些初始化的工作。
onLaunch:function(options){}
//小程序启动，或从后台进入前台显示时触发。
onShow function(options){},
//小程序从前台进入后台时触发。
onHide function(){}
})
```

#### 6. 页面的生命周期函数
小程序的页面生命周期函数需要在页面的 .js 文件中进行声明，示例代码如下：  

```JS
//页面的.js文件
Page({
onLoad	:function(options){},//监听页面加载，一个页面只调用1次
onShow 	:function(){},//监听页面显示
onReady	: function(){}//监听页面初次渲染完成，一个页面只调用1次
onHide	:function(){}//监听页面隐藏
onUnload:function(){}//监听页面卸载，一个页面只调用1次
})
```

### WXS 脚本

#### 1.什么是 wxs
WXS（WeiXin Script）是小程序独有的一套脚本语言，结合 WXML，可以构建出页面的结构。

#### 2. wxs 的应用场景

wxml 中无法调用在页面的 .js 中定义的函数，但是，wxml 中可以调用 wxs 中定义的函数。因此，小程序中
wxs 的典型应用场景就是“过滤器”。    

#### 3.wxs 和 JavaScript 的关系*

虽然 wxs 的语法类似于 JavaScript，但是 wxs 和 JavaScript 是完全不同的两种语言：

① wxs 有自己的数据类型
 number 数值类型、string 字符串类型、boolean 布尔类型、object 对象类型、
 function 函数类型、array 数组类型、 date 日期类型、 regexp 正则

② wxs 不支持类似于 ES6 及以上的语法形式
 不支持：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc...
 支持：var 定义变量、普通 function 函数等类似于 ES5 的语法

③ wxs 遵循 CommonJS 规范
 module 对象
 require() 函数
 module.exports 对象  

#### WXS 脚本 - 基础语法

##### 1. 内嵌 wxs 脚本
wxs 代码可以编写在 wxml 文件中的 <wxs> 标签内，就像 Javascript 代码可以编写在 html 文件中的 <script>
标签内一样。
wxml 文件中的每个 <wxs></wxs> 标签，必须提供 module 属性，用来指定当前 wxs 的模块名称，方便在
wxml 中访问模块中的成员  ：

```html
<view>username为{{m1.toUpper(username)}}</view>

<wxs module="m1"<--将文本转换为大写形式-->
module.exports.toUpper = function(str){
  return str.toUpperCase()
}
</wxs>
```

##### 2. 定义外联的 wxs 脚本
wxs 代码还可以编写在以 .wxs 为后缀名的文件内，就像 javascript 代码可以编写在以 .js 为后缀名的文件中
一样。示例代码如下：  

```js
function toLower(str){
  return str.toLowerCase()
}
module.exports={
  toLower:toLower
}
```

##### 3.使用外联的 wxs 脚本
在 wxml 中引入外联的 wxs 脚本时，必须为 <wxs> 标签添加 module 和 src 属性，其中：
 module 用来指定模块的名称
 src 用来指定要引入的脚本的路径，且必须是相对路径
示例代码如下：  

```html
<view>country为{{m2.toLower(country)}}</view>
<wxs src="../../utils/tools.wxs" module="m2"></wxs>
```

#### WXS 脚本 - WXS 的特点

##### 1. 与 JavaScript 不同

为了降低 wxs（WeiXin Script）的学习成本， wxs 语言在设计时借大量鉴了 JavaScript 的语法。但是本质上，
wxs 和 JavaScript 是完全不同的两种语言！  

##### 2.不能作为组件的事件回调

wxs 典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用，例如：

```html
<view>{{m2.toLower(country)}}</view>
```

但是，在 wxs 中定义的函数不能作为组件的事件回调函数。例如，下面的用法是错误的： 

```html
<button bindtaps="m2.toLower">按钮</button>
```

##### 3. 隔离性

隔离性指的是 wxs 的运行环境和其他 JavaScript 代码是隔离的。体现在如下两方面：
① wxs 不能调用 js 中定义的函数
② wxs 不能调用小程序提供的 API  

##### 4. 性能好

 在 iOS 设备上，小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍
 在 android 设备上，二者的运行效率无差异  

### 案例 - 本地生活（列表页面）

**注意：判断是否还有下一页数据**
如果下面的公式成立，则证明没有下一页数据了：
页码值 * 每页显示多少条数据 >= 总数据条数
page * pageSize >= total
案例1：总共有 77 条数据，如果每页显示 10 条数据，则总共分为 8 页，其中第 8 页只有 7 条数据
page（7）* pageSize（10） >= total（77）
page（8）* pageSize（10） >= total（77）
案例2：总共有 80 条数据，如果每页显示 10 条数据，则总共分为 8 页，其中第 8 页面有 10 条数据
page（7）* pageSize（10） >= total（80）
page（8）* pageSize（10） >= total（80）

## 小程序 - 基础加强  

### 自定义组件

#### 自定义组件 - 组件的创建与引用

##### 1. 创建组件

① 在项目的根目录中，鼠标右键，创建 components -> test 文件夹
② 在新建的 components -> test 文件夹上，鼠标右键，点击“新建 Component”
③ 键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss
注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中，例如：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650590028961.png" style="zoom:67%;" />

##### 2.引用 组件

组件的引用方式分为“局部引用”和“全局引用”，顾名思义：
 局部引用：组件只能在当前被引用的页面内使用
 全局引用：组件可以在每个小程序页面中使用  

##### 3.局部引用组件

在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下  ：

```json
//在页面的.json文件中，引入组件
{
"usingComponents":
"my-test1":"/components/test1/test1"//键值对（名称：路径）
}
```

```html
//在页面的.wxml文件中，使用组件
<my-test1></my-test1>
```

##### 4.全局引用

在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。示例代码如下：  

```json
//在app.json文件中，引入组件
{
"pages":[/*省略不必要的代码*/]，
"window":{/*省略不必要的代码*/}，
"usingComponents":{
"my-test2":"/components/test2/test2"
	}
}
```

```html
//在页面的.wxml文件中，使用组件
<my-test2></my-test2>
```

##### 5.全局引用 VS 局部引用

根据组件的使用频率和范围，来选择合适的引用方式：
 如果某组件在多个页面中经常被用到，建议进行“全局引用”
 如果某组件只在特定的页面中被用到，建议进行“局部引用”  

##### 6.组件和页面的区别
从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与
.json 文件有明显的不同：
 组件的 .json 文件中需要声明 "component": true 属性
 组件的 .js 文件中调用的是 Component() 函数
 组件的事件处理函数需要定义到 methods 节点中  

#### 自定义组件 - 样式

##### 1. 组件样式隔离

默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的
UI 结构，如图所示：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650606972182.png" style="zoom:50%;" />

 组件 A 的样式不会影响组件 C 的样式
 组件 A 的样式不会影响小程序页面的样式
 小程序页面的样式不会影响组件 A 和 C 的样式
好处：
① 防止外界的样式影响组件内部的样式
② 防止组件的样式破坏外界的样式  

##### 2. 组件样式隔离的注意点

 app.wxss 中的全局样式对组件无效
 只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响
建议：在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器！  

##### 3. 修改组件的样式隔离选项

默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。但有时，我们希望在外界能
够控制组件内部的样式，此时，可以通过 styleIsolation 修改组件的样式隔离选项，用法如下：  

```js
//在组件的.js文件中新增如下配置
Component (
options:
styleIsolation:'isolated'
)

//或在组件的.json文件中新增如下配置
{
  "styleIsolation":"isolated"
}
```

##### 4. styleIsolation 的可选值

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650614712464.png)

#### 自定义组件 - 数据、方法和属性

##### 1. data 数据

在小程序组件中，用于组件模板渲染的私有数据，需要定义到 data 节点中，示例如下：  

```js
// components/text/test.js
Component({
  /**
   * 组件的初始数据
   */
  data: {
	count: 0
  },
})
```

##### 2. methods 方法
在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中，示例代码如下：  

```js
methods: {
    //点击加一按钮的事件处理函数
    addCount(){
      this.setData({
        count:this.data.count + 1
      })
      this._showCount()
    },
    _showCount(){//展示count的值的方法
      wx.showToast({
        title: 'count是'+this.data.count,
        icon:'none'
      })
    }
  }
```

##### 3. properties 属性

在小程序组件中，properties 是组件的对外属性，用来接收外界传递到组件中的数据，示例代码如下  :

```js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    //第一种方式：简化的方式（无法指定默认值）
    max:Number,
    //第一种方式：完整的的方式（可以指定默认值）
    max:{
      type:Number,//数据类型
      value:10   //默认值为10
    }
  },
}

//结构文件就可以传递值,如下：          
<my-test1 max="9"></my-test1>                    
```

##### 4.data 和 properties 的区别
在小程序的组件中，properties 属性和 data 数据的用法相同，它们都是可读可写的，只不过：
 data 更倾向于存储组件的私有数据
 properties 更倾向于存储外界传递到组件中的数据  

```js
    showInfo(){//定义一个按钮点击打印数据的方法
      console.log(this.data)
      console.log(this.properties)
      //上面两行的打印结果是一模一样的
      console.log(this.properties===this.data)//结果为true，说明他们是一样的
    }
```

##### 5. 使用 setData 修改 properties 的值

由于 data 数据和 properties 属性在本质上没有任何区别，因此 properties 属性的值也可以用于页面渲染，
或使用 setData 为 properties 中的属性重新赋值，示例代码如下：  

```html
<-在结构文件中使用->
<view>max的属性值是：{{max}}</view>
```

```js
methods: {
    //点击加一按钮的事件处理函数
    addCount(){
      this.setData({
        count:this.data.count + 1,
        max:this.properties.max +1//同样可以修改max的值
      })
      this._showCount()
    },
  }
```

#### 自定义组件 - 数据监听器  

数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。它的作用类似于 vue 中的
watch 侦听器。在小程序组件中，数据监听器的基本语法格式如下：  

```js
Component({
  observers:{
	'字段A,字段B':function(字段A的新值，字段B的新值){
     //do something
	}
  }
})
```

##### 2.. 数据监听器的基本用法

ui结构：

```html
//组件的UI结构如下
<view>{{n1}}{{n2}}={{sum}}</view>
<button size="mini"bindtap="addN1">n1</button>
<button size="mini"bindtap="addN2">n2</button>
```

```js
  data: {//数值节点
    n1:0,
    n2:0,
    sum:0
  }
  methods: {
    addN1(){//方法节点
      this.setData({
      n1:this.data.n1+1  
      })
      },
    addN2(){
      this.setData({
        n2:this.data.n2+1  
        })
    }
  },
  observers:{//监听节点
    'n1,n2':function(newn1,newn2){//利用数据监听器获取新值
      this.setData({
        sum:newn1+newn2//通过监听器自动计算n1+n2
    })
  }
}
```

##### 3.监听对象属性的变化
数据监听器支持监听对象中单个或多个属性的变化，示例语法如下：  

```js
Component({
observers:{
'对象.属性A,对象.属性B':function(属性A的新值，属性B的新值){
    //触发此监听器的3种情况：
    //【为属性A赋值】使用setData  设置this.data.对象.属性A时触发
    //【为属性B赋值】使用setData  设置this.data.对象.属性B时触发
    //【直接为对象赋值】使用setData设置this.data.对象 时触发
    //do something...
	}
  }
})
```

##### 4.数据监听案例（色值监听并渲染）

效果：

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650623427659.png" style="zoom:67%;" />

##### 2. 渲染 UI 结构

结构：

```html
<view style="background-color: rgb({{fullcolor}});" class="colorbox">颜色值：{{fullcolor}}</view>
<button size="mini" type="default" bindtap="changeR">R</button>
<button size="mini" type="primary" bindtap="changeG">G</button>
<button size="mini" type="warn" bindtap="changeB">B</button>
<view>{{rgb.r}},{{rgb.g}},{{rgb.b}}</view>
```

样式：

```css
.colorbox{
  line-height: 200rpx;
  font-size: 24rpx;
  color: wheat;
  text-shadow: 0rpx  0rpx  2rpx black;
  text-align: center;
}
```

##### 3. 定义 button 的事件处理函数

```js
methods: {
    changeR(){
      this.setData({
        'rgb.r':this.data.rgb.r +5 >255 ? 255 :this.data.rgb.r +5 
      })
    },
    changeG(){
      this.setData({
        'rgb.g':this.data.rgb.g +5 >255 ? 255 :this.data.rgb.g +5 
      })
    },
    changeB(){
      this.setData({
        'rgb.b':this.data.rgb.b +5 >255 ? 255 :this.data.rgb.b +5 
      })
    }
  }
```

#####  4. 监听对象中指定属性的变化

```js
observers:{
    'rgb.r,rgb.g,rgb.b':function(r,g,b){
      this.setData({
        fullcolor:`${r},${g},${b}`
      })
    }
  }
```

##### 5. 监听对象中所有属性的变化
如果某个对象中需要被监听的属性太多，为了方便，可以使用通配符 ** 来监听对象中所有属性的变化，示例
代码如下：  

```js
observers:{
    'rgb.**':function(obj){
        this.setData({
            fullcolor:`${obj.r},${obj.g},${obj.b}`
        })
    }
}
```

#### 自定义组件 - 纯数据字段

##### 1.什么是纯数据字段

概念：纯数据字段指的是那些不用于界面渲染的 data 字段。
应用场景：例如有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前
组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段。
好处：纯数据字段有**助于提升页面更新的性能。**  

##### 2. 使用规则

在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个正则表达式，字段名符合这个正则
表达式的字段将成为纯数据字段，示例代码如下：  

```js
Component({
    options:{
        //指定所有开头的数据字段为纯数据字段
        pureDataPattern:/^_/
    }，
    data:{
        a:true,//普通数据字段
        _b:true,//纯数据字段
     }
})
```

##### 3. 使用纯数据字段改造数据监听器案例  

```js
// components/test3/test3.js
Component({
  options:{
    pureDataPattern:/^_/
  },
  /**
   * 组件的初始数据
   */
  data: {
    _rgb:{		//rgb颜色值对象
      r:0,
      g:0,
      b:0
    },
    fullcolor:'0,0,0'//根据rgb值的三个属性，动态计算fullcolor的值
  },
}
```

#### 自定义组件 - 组件的生命周期  

##### 1.组件全部的生命周期函数
小程序组件可用的全部生命周期如下表所示：  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650626485619.png)

##### 2. 组件主要的生命周期函数
在小程序组件中，最重要的生命周期函数有 3 个，分别是 created、attached、detached。它们各自的特点
如下：
① 组件实例刚被创建好的时候，created 生命周期函数会被触发
⚫ 此时还不能调用 setData
⚫ 通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段
② 在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发
⚫ 此时， this.data 已被初始化完毕
⚫ 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）
③ 在组件离开页面节点树后， detached 生命周期函数会被触发
⚫ 退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数
⚫ 此时适合做一些清理性质的工作  

##### 3. lifetimes 节点
在小程序组件中，生命周期函数可以直接定义在 Component 构造器的第一级参数中，可以在 lifetimes 字段
内进行声明（这是推荐的方式，其优先级最高）。示例代码如下  

```js
Component({
//推荐用法
lifetimes:{
attached(){},//在组件实例进入页面节点树时执行
detached(){},//在组件实例被从页面节点树移除时执行
}
//以下是旧式的定义方式
attached(){},//在组件实例进入页面节点树时执行
detached(){},//在组件实例被从页面节点树移除时执行
})
```

#### 自定义组件 - 组件所在页面的生命周期

##### 1.什么是组件所在页面的生命周期  

有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。
例如：每当触发页面的 show 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。
在自定义组件中，组件所在页面的生命周期函数有如下 3 个，分别是：  

![](https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650628222265.png)

##### 2. pageLifetimes 节点
组件所在页面的生命周期函数，需要定义在 pageLifetimes 节点中，示例代码如下：  

```js
Component({
pageLifetimes:{
    show:function(){},//页面被展示
    hide:function(){},//页面被隐藏
    resize:function(siZe){}//页面尺寸变化
}
})
```

##### 3.生成随机的 RGB 颜色值  

```js
_randomColor(){
      this.setData({
        _rgb:{
          r:Math.floor(Math.random()*256),
          g:Math.floor(Math.random()*256),
          b:Math.floor(Math.random()*256)
        }
      })
    }
pageLifetimes:{//所在页面的生命周期函数
    show(){
      this._randomColor()
    }
  }
```

#### 自定义组件 - 插槽  

#### 1.什么是插槽
在自定义组件的 wxml 结构中，可以提供一个 <slot> 节点（插槽），用于承载组件使用者提供的 wxml 结构。  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650629473452.png" style="zoom:67%;" />

##### 2. 单个插槽
在小程序中，默认每个自定义组件中只允许使用一个 <slot> 进行占位，这种个数上的限制叫做单个插槽  

```html
<!--组件的封装者-->
<view class="wrapper">
<view>这里是组件的内部节点</view>
<!--对于不确定的内容，可以使用<s1ot>进行占位，具体的内容由组件的使用者决定-->
<slot></slot>
</view>
    
<!--组件的使用者-->
<component-tag-name>
<!--这部分内容将被放置在组件<s1ot>的位置上-->
<view>这里是插入到组件slot中的内容</view>
</component-tag-name>
```

##### 3.启用多个插槽

在小程序的自定义组件中，需要使用多 <slot> 插槽时，可以在组件的 .js 文件中，通过如下方式进行启用。
示例代码如下：  

```js
Component({
  options:{
	multipleSlots:true//在组件定义时的选项中启用多slot支持
},
properties:{/*...*/},
methods:{/*...*/}
})
```

##### 4.定义多个插槽

可以在组件的 .wxml 中使用多个 <slot> 标签，以不同的 name 来区分不同的插槽。示例代码如下：  

```html
<!--组件模板->
<view class="wrapper">
<!--name为before的第一个slot插槽-->
<slot name="before"></slot>
<view>这是一段固定的文本内容<view>
<!--name为after的第二个slot插槽-->
<slot name="after"></slot>
</view>
```

##### 5. 使用多个插槽
在使用带有多个插槽的自定义组件时，需要用 slot 属性来将节点插入到不同的 <slot> 中。示例代码如下：  

```html
<!--引用组件的页面模板-->
<component-tag-name>
<!--这部分内容将被放置在组件<slot name="before">的位置上-->
<view slot="before">这里是插入到组件slot name="before"中的内容</view>
<!--这部分内容将被放置在组件<slot name="after">的位置上-->
<view slot="after">这里是插入到组件slot name="after"中的内容<view
</component-tag-name>
```

#### 自定义组件 - 父子组件之间的通信  

##### 1. 父子组件之间通信的 3 种方式
① 属性绑定
⚫ 用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据
② 事件绑定
⚫ 用于子组件向父组件传递数据，可以传递任意数据
③ 获取组件实例
⚫ 父组件还可以通过 this.selectComponent() 获取子组件实例对象
⚫ 这样就可以直接访问子组件的任意数据和方法  

##### 2. 属性绑定
属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件。父组件的示例代码
如下：

```js
//父组件的data节点
data:{
count:0
}
//父组件的Wxml结构
<my-test5 count="{{count}}"></my-test5>
<view>~~~~</view>
<view>父组件中，count值为：{{count}}</view>
```

子组件在 properties 节点中声明对应的属性并使用。示例代码如下：  

```js
//子组件的properties节点
properties:{
count:Number
},
//子组件的wxml结构
<text>子组件中，count值为：{{count}}</text>
```

##### 3. 事件绑定

事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下：
① 在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件
② 在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件
③ 在子组件的 js 中，通过调用 this.triggerEvent('自定义事件名称', { /* 参数对象 */ }) ，将数据发送到父组件
④ 在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据  

步骤1：在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件。  

```js
//在父组件中定义syncCount方法
//将来，这个方法会被传递给子组件，供子组件进行调用
syncCount(e){
    // console.log('syncCount')
    // console.log(e.detail.value)
    this.setData({
      count:e.detail.value
    })
  },
```

步骤2：在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件。  

```html
<!--使用bind:自定义事件名称（推荐：结构清晰-->
<my-test3 count="{{count}}"bind:sync="syncCount"></my-test3>
<!--或在bind后面直接写上自定义事件名称-->
<my-test3 count="{{count}}"bindsync="syncCount"></my-test3>
```

步骤3：在子组件的 js 中，通过调用 this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ }) ，将数据发送到父组件。  

```js
//子组件的wxml结构
<text>子组件中，count值为：{{count}}</text>
<button bindtap="addCount">count+1</button>
//子组件的js代码
 methods: {
    addCount(){
      this.setData({
        count:this.data.count+1
      })
      //触发自定义事件，将数值同步给组件
    this.triggerEvent('sync',{value:this.properties.count})
    }
  }
```

步骤4：在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据。  

```js
syncCount(e){
    this.setData({
      count:e.detail.value
    })
  },
```

##### 4. 获取组件实例(没太懂2022.4.23)

可在父组件里调用 this.selectComponent("id或class选择器") ，获取子组件的实例对象，从而直接访问子组
件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(".my-component")。  

```js
//Xml结构
<my-test3 count="{{count}}"bind:sync="syncCount"class="customA"id="CA">
</my-test3>
<button bindtap="getChild">获取子组件实例</button>

//js
getChild(){//按钮的tap事件处理函数
/切记下面参数不能传递标签选择器'my-test3',不然返回的是nul1
    const child=this.selectComponent('.customA')//也可以传递id选择器#cA
    child.setData({count:child.properties.count+1})//调用子组件的setData方法
    child.addCount()//调用子组件的addCount方法
}
```

#### 自定义组件 - behaviors  

##### 1.什么是 behaviors
behaviors 是小程序中，用于实现组件间代码共享的特性，类似于 Vue.js 中的 “mixins”。  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650675866671.png" style="zoom:67%;" />

##### 2.behaviors 的工作方式
每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被
合并到组件中。
每个组件可以引用多个 behavior，behavior 也可以引用其它 behavior。

##### 3.创建 behavior
调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使用：  

```js
//调用Behavior()方法，创建实例对象
//并使用module.exports将behavior实例对象共享出去
module.exports = Behavior({
  data:{
    uesrname:'zs'
  },
  properties:{},
  methods:{}
  })
```

#### 4. 导入并使用 behavior
在组件中，使用 require() 方法导入需要的 behavior，挂载后即可访问 behavior 中的数据或方法，示例代码
如下：  

```js
// components/test5/test5.js
//使用 require() 方法导入需要的 behavior
const myBehavior=require('../../behaviors/my-behavior')
Component({
    //将实例挂载到behavior 中的数组结点
  behaviors:[myBehavior],
})
```

##### 5. behavior 中所有可用的节点  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650677157797.png" style="zoom:67%;" />

##### 6. 同名字段的覆盖和组合规则*

组件和它引用的 behavior 中可以包含同名的字段，此时可以参考如下 3 种同名时的处理规则：
① 同名的数据字段 (data)
② 同名的属性 (properties) 或方法 (methods)
③ 同名的生命周期函数
关于详细的覆盖和组合规则，大家可以参考微信小程序官方文档给出的说明：
https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html  

###  使用 npm 包

#### 使用 npm 包—Vant Weapp

##### 小程序对 npm 的支持与限制

目前，小程序中已经支持使用 npm 安装第三方包，从而来提高小程序的开发效率。但是，在小程序中使用
npm 包有如下 3 个限制：
① 不支持依赖于 Node.js 内置库的包
② 不支持依赖于浏览器内置对象的包
③ 不支持依赖于 C++ 插件的包
总结：虽然 npm 上的包有千千万，但是能供小程序使用的包却“为数不多”。  

##### 什么是 Vant Weapp

Vant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是
MIT 开源许可协议，对商业使用比较友好。
官方文档地址 https://youzan.github.io/vant-weapp  

##### 2. 安装 Vant 组件库
在小程序项目中，安装 Vant 组件库主要分为如下 3 步：
① 通过 npm 安装（建议指定版本为@1.3.3）
② 构建 npm 包
③ 修改 app.json
详细的操作步骤，大家可以参考 Vant 官方提供的快速上手教程：
https://youzan.github.io/vant-weapp/#/quickstart#an-zhuang  

##### 3. 使用 Vant 组件

安装完 Vant 组件库之后，可以在 app.json 的 usingComponents 节点中引入需要的组件，即可在 wxml 中
直接使用组件。示例代码如下：  

```json
"usingComponents": {
  "van-button": "path/to/vant-weapp/dist/button/index"
}
```

##### 4. 定制全局主题样式

Vant Weapp 使用 CSS 变量来实现定制主题。 关于 CSS 变量的基本用法，请参考 MDN 文档：
https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties  

##### 5.定制全局主题样式
在 app.wxss 中，写入 CSS 变量，即可对全局生效：

```css
/**app.wxss**/
 page{/*page是根结点*/
     /*自定义告警结点的样式*/
  --button-danger-background-color:#C00000;
  --button-danger-border-color:#D60000;
}
```

所有可用的颜色变量，请参考 Vant 官方提供的配置文件：
https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less  

#### 使用 npm 包 - API Promise化

##### 1.基于回调函数的异步 API 的缺点

默认情况下，小程序官方提供的异步 API 都是基于回调函数实现的，例如，网络请求的 API 需要按照如下的方
式调用：

```js
wx.request({
method:'',
url:'',
data:{},
success:()=>{},//请求成功的回调函数
fail:()=>{},//请求失败的回调函数
complete:()=>{}//请求完成的回调函数
})
```

缺点：容易造成回调地狱的问题，代码的可读性、维护性差！  

##### 2. 什么是 API Promise 化
API Promise化，指的是通过额外的配置，将官方提供的、基于回调函数的异步 API，升级改造为基于
Promise 的异步 API，从而提高代码的可读性、维护性，避免回调地狱的问题。  

##### 3. 实现 API Promise 化

在小程序中，实现 API Promise 化主要依赖于 miniprogram-api-promise 这个第三方的 npm 包。它的安装
和使用步骤如下：  

命令行安装命令：

```json
npm install --save miniprogram-api-promise@1.0.4
```

使用：

```js
//在小程序入口文件中(app.js),只需调用一次promisifyAll()方法，
//即可实现异步API的Promise化
import {promisifyAll} from 'miniprogram-api-promise'
const wxp wx.p ={}
//promisify all wx's api
promisifyAll(wx,wxp)
```

##### 4. 调用 Promise 化之后的异步 API  

```js
  getInfo(){
    const res= wx.p.request({
      method:'get',
      url:'https://www.escook.cn/api/get',
      data:{
        name:'zs',
        age:20
      }
    })
    console.log(res)
  },
```

### 全局数据共享

#### 1. 什么是全局数据共享

全局数据共享（又叫做：状态管理）是为了解决组件之间数据共享的问题。
开发中常用的全局数据共享方案有：Vuex、Redux、MobX 等。  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1650682083381.png" style="zoom:67%;" />

#### 2. 小程序中的全局数据共享方案
在小程序中，可使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享。其中：
 mobx-miniprogram 用来创建 Store 实例对象
 mobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用  

#### 全局数据共享 - MobX

##### 1. 安装 MobX 相关的包

在项目中运行如下的命令，安装 MobX 相关的包：

```
npm install --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1
```

注意：MobX 相关的包安装完毕之后，记得重新构建 npm。  

##### 2. 创建 MobX 的 Store 实例

[参考：微信小程序中的vuex（MobX）](https://blog.csdn.net/ct5211314/article/details/120322080?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165068256216780357299904%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165068256216780357299904&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-120322080.142^v9^control,157^v4^control&utm_term=%E5%B0%8F%E7%A8%8B%E5%BA%8FMobX&spm=1018.2226.3001.4187)

```js
//在这个js，文件中，专门创建store实例对象
import {observable,action} from 'mobx-miniprogram'//这里导出observable和action方法，后面才能使用
//observable创建仓库
export const store = observable({
  // 数据字段
  numA: 1,
  numB: 2,

  // 计算属性 数据改变时会执行，vue中的计算属性，返回sum这个变量

  get sum() {
    return this.numA + this.numB
  },

  //actions 方法用于改变仓库的值
  updateNum1: action(function (step) {
    this.numA += step   
  }),
  updateNum2: action(function (step) {
    this.numB += step
  })
});
```

#####  3. 将 Store 中的成员绑定到页面中

页面的JS文件

```js
import { createStoreBindings } from "mobx-miniprogram-bindings";//导入createStoreBindings的方法，可以将数据绑定至页面
import { store } from "../../store/store";//导入store实例
Page({
  data: {
    someData: "...",
  },
  onLoad() function (options){//生命周期函数--监听页面加载
    this.storeBindings = createStoreBindings(this, {
      store,//数据源
      fields: ["numA", "numB", "sum"],//公共变量
      actions: ["update"],//公共方法
    })
  },
  onUnload() function (){//生命周期函数--监听页面卸载
    this.storeBindings.destroyStoreBindings();//数据清理
  },
  myMethod() {
    this.data.sum; // 来自于 MobX store 的字段
  },
});
```

##### 4.在页面使用store的成员

页面结构：

```html
<!--pages/message/message.wxml-->
<text>pages/message/message.wxml</text>
<view></view>
<van-button type="primary" bindtap="btnHandler1" data-step="{{1}}"><!--加一按钮-->
    numA + 1
</van-button>
<van-button type="danger"  bindtap="btnHandler1" data-step="{{-1}}"><!--减一按钮-->
    numA -1
</van-button>
<view>{{numA}}+{{numB}}={{sum}}</view>
```

js函数方法：

```js
//加一减一按钮的事件处理函数
  btnHandler1(e){
    this.updateNum1(e.target.dataset.step)
  },
```

##### 5.将 Store 中的成员绑定到组件中

```js
// components/numbes/numnes.js
import {storeBindingsBehavior} from 'mobx-miniprogram-bindings'//导入mobx-miniprogram-bindings包的storeBindingsBehavior
import {store} from '../../store/store'//导入stord实例
Component({
  behaviors:[storeBindingsBehavior],//通过storeBindingsBehavior实现自动绑定
  storeBindings:{
    //指定要绑定的Store
    store,
    fields:{//指定要绑定的字段数据
      numA:'numA',//前者是组件中自定义的数据名后者是对应store中的数据,前者可以自定义
      numB:'numB',
      sum:'sum'
    },
    actions: ["updateNum2"],//公共方法updateNum2
  },
})
```

##### 6. 在组件中使用 Store 中的成员

结构:

```html
<van-button type="primary" bindtap="btnHandler2" data-step="{{1}}">numB + 1</van-button>
<van-button type="danger"  bindtap="btnHandler2" data-step="{{-1}}">numB -1</van-button>
<view>{{numA}}+{{numB}}={{sum}}</view>
```

处理函数:

```js
 methods: {
    btnHandler2(e){
      console.log(e)
      this.updateNum2(e.target.dataset.step)
    }   
    }
```

###  分包

#### 分包-基础概念

##### 1.什么是分包

分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。 

##### 2. 分包的好处

对小程序进行分包的好处主要有以下两点：
 可以优化小程序首次启动的下载时间
在多团队共同开发时可以更好的解耦协作   

##### 3.分包前项目的构成

分包前，小程序项目中所有的页面和资源都被打包到了一起，导致整个项目体积过大，影响小程序首次启动的下载时间。  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1651288715815.png" style="zoom:67%;" />

##### 4.分包后项目的构成

分包后，小程序项目由 1 个主包 + 多个分包组成：
 主包：一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源
 分包：只包含和当前分包有关的页面和私有资源  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1651288805650.png" style="zoom:67%;" />

##### 5. 分包的加载规则

① 在小程序启动时，默认会下载主包并启动主包内页面
 tabBar 页面需要放到主包中
② 当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示
 非 tabBar 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载  

##### 6. 分包的体积限制

目前，小程序分包的大小有以下两个限制：
 整个小程序所有分包大小不超过 16M（主包 + 所有分包）
 单个分包/主包大小不能超过 2M  

#### 分包 - 使用分包

#####  1.配置方法

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1651289216956.png" style="zoom:67%;" />

#####  2.打包原则

① 小程序会按 subpackages 的配置进行分包，subpackages 之外的目录将被打包到主包中
② 主包也可以有自己的 pages（即最外层的 pages 字段）
③ tabBar 页面必须在主包内
④ 分包之间不能互相嵌套  

##### 3.引用原则

① 主包无法引用分包内的私有资源
② 分包之间不能相互引用私有资源
③ 分包可以引用主包内的公共资源  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1651289751946.png" style="zoom:67%;" />

#### 分包-独立分包

##### 1. 什么是独立分包
独立分包本质上也是分包，只不过它比较特殊，可以独立于主包和其他分包而单独运行。  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1651289989478.png" style="zoom:67%;" />

##### 2. 独立分包和普通分包的区别
最主要的区别：是否依赖于主包才能运行
 普通分包必须依赖于主包才能运行
 独立分包可以在不下载主包的情况下，独立运行  

##### 3. 独立分包的应用场景

开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中。原因如下：
当小程序从普通的分包页面启动时，需要首先下载主包
而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度
注意：一个小程序中可以有多个独立分包。  

##### 4. 独立分包的配置方法

在分包配置里加入

```js
"independent": true
```

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1651290400594.png" style="zoom:67%;" />

##### 5. 引用原则

独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源！例如：
① 主包无法引用独立分包内的私有资源
② 独立分包之间，不能相互引用私有资源
③ 独立分包和普通分包之间，不能相互引用私有资源
④ **特别注意：**独立分包中不能引用主包内的公共资源  

#### 分包 - 分包预下载

##### 1. 什么是分包预下载

分包预下载指的是：在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包
页面时的启动速度。  

##### 2. 配置分包的预下载

预下载分包的行为，会在进入指定的页面时触发。在 app.json 中，使用 preloadRule 节点定义分包的预下载
规则，示例代码如下：  

```json
"preloadRule": {//分包预下载的规则
    "pages/contact/contact":{//触发分包预下载的页面路径
        //packages表示进入页面后，预下载哪些分包
        "packages": ["pagA"],
            "network": "all"
        //network表示在指定的网络模式下进行预下载，
        //可选值为：al1(不限网络)和wifi(仅wifi模式下进行预下载)
    }
```

##### 3. 分包预下载的限制

同一个分包中的页面享有共同的预下载大小限额 2M，例如：  

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1651291569392.png" style="zoom:67%;" />

###  案例 - 自定义 tabBar

#### 1.案例效果

<img src="https://image-1308319148.cos.ap-chengdu.myqcloud.com/main/1651291693861.png" style="zoom:67%;" />

#### [自定义tabBar](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html)

##### 使用流程

###### 1. 配置信息

- 在 `app.json` 中的 `tabBar` 项指定 `custom` 字段，同时其余 `tabBar` 相关配置也补充完整。
- 所有 tab 页的 json 里需声明 `usingComponents` 项，也可以在 `app.json` 全局开启。

示例：

```json
{
  "tabBar": {
    "custom": true,
    "color": "#000000",
    "selectedColor": "#000000",
    "backgroundColor": "#000000",
    "list": [{
      "pagePath": "page/component/index",
      "text": "组件"
    }, {
      "pagePath": "page/API/index",
      "text": "接口"
    }]
  },
  "usingComponents": {}
}
```

###### 2. 添加 tabBar 代码文件

在代码根目录下添加入口文件:

```text
custom-tab-bar/index.js
custom-tab-bar/index.json
custom-tab-bar/index.wxml
custom-tab-bar/index.wxss
```

######3. 编写 tabBar 代码

用自定义组件的方式编写即可，该自定义组件完全接管 tabBar 的渲染。另外，自定义组件新增 `getTabBar` 接口，可获取当前页面下的自定义 tabBar 组件实例。
